<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Virus vs Antivirus ‚Äî Boss Fight (3 —Ñ–∞–∑—ã)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0a0d10;
      color: #cfefff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      overflow: hidden;
    }
    #wrap {
      position: relative;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: crisp-edges;
      image-rendering: -webkit-optimize-contrast;
      background: radial-gradient(1200px 800px at 50% 50%, #0f1620 0%, #0c1118 60%, #0a0d10 100%);
    }
    .overlay {
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      display: flex;
      align-items: center; justify-content: center;
      pointer-events: none;
      text-align: center;
      padding: 24px;
    }
    .overlay .panel {
      pointer-events: auto;
      background: rgba(10,13,16,0.7);
      border: 1px solid rgba(120,220,255,0.2);
      border-radius: 12px;
      padding: 20px 24px;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      max-width: 720px;
    }
    .btn {
      display: inline-block;
      margin-top: 14px;
      padding: 10px 16px;
      border: 1px solid rgba(120,220,255,0.4);
      border-radius: 8px;
      color: #cfefff;
      text-decoration: none;
      cursor: pointer;
      background: rgba(29,60,80,0.3);
    }
    .btn:hover { background: rgba(29,60,80,0.45); }
    .hud {
      position: absolute; left: 0; right: 0; top: 0;
      padding: 10px 14px;
      display: flex; justify-content: space-between; align-items: center;
      font-size: 14px; letter-spacing: 0.3px;
      user-select: none;
      pointer-events: none;
      text-shadow: 0 0 6px rgba(0,255,255,0.25);
    }
    .hud .hearts {
      display: inline-flex; gap: 6px;
    }
    .chip {
      display: inline-block;
      padding: 4px 8px;
      border: 1px solid rgba(120,220,255,0.3);
      border-radius: 999px;
      background: rgba(18,40,54,0.4);
      margin-left: 6px;
    }
    .bar {
      width: 40vw; max-width: 520px; min-width: 220px;
      height: 12px; border: 1px solid rgba(255,80,120,0.4); border-radius: 8px;
      background: rgba(40,8,16,0.4); overflow: hidden;
    }
    .bar .fill {
      height: 100%; background: linear-gradient(90deg, #ff2a6f, #ffa3c3);
      box-shadow: 0 0 12px rgba(255, 80, 120, 0.65);
      width: 100%;
    }
    .tiny {
      font-size: 12px; opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>

    <div class="hud" id="hud" style="display:none;">
      <div>
        <span>–ñ–∏–∑–Ω–∏:</span>
        <span class="hearts" id="hearts"></span>
        <span class="chip" id="phaseChip">–§–∞–∑–∞: 1/3</span>
        <span class="chip tiny" id="chipInfo">WASD/‚Üê‚Üë‚Üí‚Üì ‚Äî –¥–≤–∏–∂; –õ–ö–ú ‚Äî –æ–≥–æ–Ω—å; P ‚Äî –ø–∞—É–∑–∞; M ‚Äî –∑–≤—É–∫; G ‚Äî –≥—Ä–∞—Ñ–∏–∫–∞</span>
      </div>
      <div style="display:flex; align-items:center; gap:10px;">
        <div style="text-align:right">
          <div>–ê–Ω—Ç–∏–≤–∏—Ä—É—Å</div>
          <div class="tiny" id="bossHPText">HP</div>
        </div>
        <div class="bar"><div class="fill" id="bossHPFill"></div></div>
      </div>
    </div>

    <div class="overlay" id="menu">
      <div class="panel">
        <h2>–Ø ‚Äî –í–∏—Ä—É—Å. –ù–∞ –º–µ–Ω—è –æ—Ö–æ—Ç–∏—Ç—Å—è –ê–Ω—Ç–∏–≤–∏—Ä—É—Å (–±–æ—Å—Å –∏–∑ 3 —Ñ–∞–∑)</h2>
        <p>–í—ã–∂–∏–≤–∞–π, —É–≤–æ—Ä–∞—á–∏–≤–∞–π—Å—è –æ—Ç ‚Äú–º–∞–ª–µ–Ω—å–∫–∏—Ö –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–æ–≤‚Äù –∏ —Å–Ω–∞—Ä—è–¥–æ–≤ –±–æ—Å—Å–∞, —Å—Ç—Ä–µ–ª—è–π –∏–Ω—Ñ–µ–∫—Ü–∏–æ–Ω–Ω—ã–º–∏ –ø–∞–∫–µ—Ç–∞–º–∏.</p>
        <p>
          –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD/—Å—Ç—Ä–µ–ª–∫–∏ ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ, –º—ã—à—å ‚Äî –ø—Ä–∏—Ü–µ–ª, –õ–ö–ú ‚Äî –æ–≥–æ–Ω—å, P ‚Äî –ø–∞—É–∑–∞, M ‚Äî –∑–≤—É–∫, G ‚Äî –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Å–≤–µ—á–µ–Ω–∏–µ.
        </p>
        <a class="btn" id="startBtn">–ò–≥—Ä–∞—Ç—å</a>
      </div>
    </div>

    <div class="overlay" id="pause" style="display:none;">
      <div class="panel">
        <h3>–ü–∞—É–∑–∞</h3>
        <p>–ù–∞–∂–º–∏ P, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.</p>
      </div>
    </div>

    <div class="overlay" id="end" style="display:none;">
      <div class="panel" id="endPanel"></div>
    </div>
  </div>

<script>
(() => {
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞–Ω–≤–∞—Å–∞ —Å —É—á–µ—Ç–æ–º DPI
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let DPR = Math.min(window.devicePixelRatio || 1, 2);
  let W = 0, H = 0, CX = 0, CY = 0;

  function resize() {
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    const { clientWidth, clientHeight } = canvas;
    canvas.width = Math.floor(clientWidth * DPR);
    canvas.height = Math.floor(clientHeight * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    W = clientWidth; H = clientHeight; CX = W / 2; CY = H / 2;
  }

  // UI —ç–ª–µ–º–µ–Ω—Ç—ã
  const hud = document.getElementById('hud');
  const heartsBox = document.getElementById('hearts');
  const phaseChip = document.getElementById('phaseChip');
  const bossHPFill = document.getElementById('bossHPFill');
  const bossHPText = document.getElementById('bossHPText');
  const menu = document.getElementById('menu');
  const pauseOverlay = document.getElementById('pause');
  const endOverlay = document.getElementById('end');
  const endPanel = document.getElementById('endPanel');
  const startBtn = document.getElementById('startBtn');

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
  const TAU = Math.PI * 2;
  const rand = (a = 1, b) => (b === undefined ? Math.random() * a : a + Math.random() * (b - a));
  const randInt = (a, b) => Math.floor(rand(a, b + 1));
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const len = (x, y) => Math.hypot(x, y);
  const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
  const angleBetween = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax);
  const lerp = (a, b, t) => a + (b - a) * t;
  const now = () => performance.now();

  // –≠–∫—Ä–∞–Ω–Ω–∞—è —Ç—Ä—è—Å–∫–∞
  let shake = 0;
  function addShake(s) { shake = Math.max(shake, s); }

  // –ê—É–¥–∏–æ (–æ—á–µ–Ω—å –ª—ë–≥–∫–∏–π synth)
  const audio = {
    ctx: null,
    enabled: true,
    init() {
      if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },
    beep(type = 'sine', f = 440, dur = 0.08, vol = 0.04) {
      if (!this.enabled) return;
      try {
        this.init();
        const t0 = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(f, t0);
        g.gain.setValueAtTime(vol, t0);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
        o.connect(g).connect(this.ctx.destination);
        o.start(t0);
        o.stop(t0 + dur);
      } catch(e) {}
    }
  };

  // –ì—Ä–∞—Ñ–∏–∫–∞: –º–æ–∂–Ω–æ –≤—ã–∫–ª—é—á–∞—Ç—å —Å–≤–µ—á–µ–Ω–∏–µ (–¥–ª—è —Å–ª–∞–±—ã—Ö –ü–ö)
  let glowEnabled = true;

  // –í–≤–æ–¥
  const keys = new Set();
  const mouse = { x: 0, y: 0, down: false, justPressed: false };

  window.addEventListener('resize', resize);
  window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyP') togglePause();
    else if (e.code === 'KeyM') audio.enabled = !audio.enabled;
    else if (e.code === 'KeyG') glowEnabled = !glowEnabled;
    else keys.add(e.code);
  });
  window.addEventListener('keyup', (e) => { keys.delete(e.code); });
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mousedown', () => { mouse.down = true; mouse.justPressed = true; audio.init(); });
  canvas.addEventListener('mouseup', () => { mouse.down = false; });

  // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
  const State = { Menu: 'menu', Playing: 'playing', Paused: 'paused', Win: 'win', Lose: 'lose' };
  let gameState = State.Menu;

  // –ò–≥—Ä–æ–∫ (–í–∏—Ä—É—Å)
  const player = {
    x: 0, y: 0, vx: 0, vy: 0,
    r: 14,
    speed: 300,
    friction: 0.86,
    angle: 0,
    shootCD: 0,
    shootRate: 0.16,
    lives: 5,
    invul: 0,
    alive: true,
  };

  // –ë–æ—Å—Å (–ê–Ω—Ç–∏–≤–∏—Ä—É—Å)
  const boss = {
    x: 0, y: 0, vx: 0, vy: 0,
    r: 60,
    color: '#ff2a6f',
    // HP –ø–æ —Ñ–∞–∑–∞–º: feel free –ø–æ–¥—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –±–∞–ª–∞–Ω—Å
    phase: 1,
    phaseHP: [100, 140, 200],
    hp: 100 + 140 + 200,
    timers: {
      aimed: 0, ring: 0, drone: 0, spiral: 0, dash: 2.2, sweep: 0, missile: 0
    },
    substate: 'idle',
    subTimer: 0,
  };

  // –ö–æ–ª–ª–µ–∫—Ü–∏–∏ –æ–±—ä–µ–∫—Ç–æ–≤
  const playerBullets = [];
  const bossBullets = [];
  const drones = [];
  const particles = [];

  function resetGame() {
    player.x = CX; player.y = H * 0.78;
    player.vx = player.vy = 0;
    player.lives = 3; player.invul = 1.2; player.alive = true;
    player.shootCD = 0;

    boss.x = CX; boss.y = H * 0.28;
    boss.vx = boss.vy = 0;
    boss.phase = 1;
    boss.phaseHP = [220, 260, 320];
    boss.hp = boss.phaseHP[0] + boss.phaseHP[1] + boss.phaseHP[2];
    boss.timers = { aimed: 0, ring: 0, drone: 0, spiral: 0, dash: 2.2, sweep: 0, missile: 0 };
    boss.substate = 'idle';
    boss.subTimer = 0;

    playerBullets.length = 0;
    bossBullets.length = 0;
    drones.length = 0;
    particles.length = 0;

    hud.style.display = 'flex';
    updateHUD();
  }

  function currentPhaseHPLeft() {
    const p = boss.phase - 1;
    let sumPrev = 0;
    for (let i = 0; i < p; i++) sumPrev += boss.phaseHP[i];
    return boss.hp - sumPrev;
  }

  function totalHPBeforePhase(phase) {
    let s = 0;
    for (let i = 0; i < phase - 1; i++) s += boss.phaseHP[i];
    return s;
  }

  function updateHUD() {
    // –ñ–∏–∑–Ω–∏
    heartsBox.innerHTML = '';
    for (let i = 0; i < 3; i++) {
      const full = i < player.lives;
      const span = document.createElement('span');
      span.innerHTML = full ? 'üß¨' : '‚ö¨';
      span.style.filter = full ? 'drop-shadow(0 0 8px rgba(0,255,255,0.5))' : 'none';
      heartsBox.appendChild(span);
    }
    // –§–∞–∑–∞
    phaseChip.textContent = `–§–∞–∑–∞: ${boss.phase}/3`;
    // HP –±–∞—Ä
    const hpRatio = clamp(boss.hp / (boss.phaseHP[0] + boss.phaseHP[1] + boss.phaseHP[2]), 0, 1);
    bossHPFill.style.width = `${hpRatio * 100}%`;
    bossHPText.textContent = `HP: ${Math.max(0, Math.ceil(boss.hp))}`;
  }

  // –ß–∞—Å—Ç–∏—Ü—ã
  function spawnParticles(x, y, color, count = 12, speed = 140, life = 0.6) {
    for (let i = 0; i < count; i++) {
      const a = rand(0, TAU);
      particles.push({
        x, y,
        vx: Math.cos(a) * rand(speed*0.4, speed),
        vy: Math.sin(a) * rand(speed*0.4, speed),
        r: rand(1.2, 2.8),
        life: life * rand(0.7, 1.2),
        color,
      });
    }
  }

  // –°–Ω–∞—Ä—è–¥—ã
  function spawnPlayerBullet() {
    const ang = player.angle;
    const speed = 520;
    const spread = 0.06;
    const a = ang + rand(-spread, spread);
    const vx = Math.cos(a) * speed;
    const vy = Math.sin(a) * speed;
    playerBullets.push({
      x: player.x + Math.cos(a) * (player.r + 6),
      y: player.y + Math.sin(a) * (player.r + 6),
      vx, vy, r: 4.5, life: 2.0, color: '#39e8ff'
    });
    audio.beep('triangle', rand(740, 820), 0.06, 0.03);
  }

  function spawnBossBullet(x, y, dir, speed, r=5, type='normal', color='#ff6b9e') {
    bossBullets.push({ x, y, vx: Math.cos(dir)*speed, vy: Math.sin(dir)*speed, r, life: 8, type, color, angle: dir, turn: 0 });
  }

  function spawnDrone() {
    const edge = randInt(0, 3);
    let x, y;
    if (edge === 0) { x = rand(40, W-40); y = 50; }
    else if (edge === 1) { x = rand(40, W-40); y = H-50; }
    else if (edge === 2) { x = 50; y = rand(40, H-40); }
    else { x = W-50; y = rand(40, H-40); }
    const speed = rand(60, 100) + boss.phase * 15;
    const a = rand(0, TAU);
    drones.push({
      x, y,
      vx: Math.cos(a)*speed, vy: Math.sin(a)*speed,
      r: 8.5,
      jitter: rand(0.8, 1.6), // —Å—Ç–µ–ø–µ–Ω—å —Ö–∞–æ—Å–∞
      color: '#ffd166',
      life: rand(10, 16),
    });
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–∑ –±–æ—Å—Å–∞
  function bossBehavior(dt) {
    // –ü–µ—Ä–µ—Ö–æ–¥—ã –ø–æ HP
    if (boss.phase < 3 && boss.hp <= totalHPBeforePhase(boss.phase + 1)) {
      // –ø–µ—Ä–µ—Ö–æ–¥ –≤ —Å–ª–µ–¥—É—é—â—É—é —Ñ–∞–∑—É
      boss.phase++;
      boss.substate = 'transition';
      boss.subTimer = 1.1;
      addShake(12);
      spawnParticles(boss.x, boss.y, '#ff2a6f', 60, 220, 0.9);
      audio.beep('sawtooth', 300, 0.25, 0.06);
      audio.beep('sawtooth', 240, 0.35, 0.06);
    }
    // –ü–æ–±–µ–¥–∞
    if (boss.hp <= 0) {
      gameWin();
      return;
    }

    // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –±–æ—Å—Å–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ø–æ–ª—è
    boss.x = clamp(boss.x, 60, W-60);
    boss.y = clamp(boss.y, 60, H-60);

    // –¢–∞–π–º–µ—Ä—ã
    boss.timers.aimed -= dt;
    boss.timers.ring -= dt;
    boss.timers.drone -= dt;
    boss.timers.spiral -= dt;
    boss.timers.dash -= dt;
    boss.timers.sweep -= dt;
    boss.timers.missile -= dt;

    // –ë–∞–∑–æ–≤–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ ‚Äî –Ω–µ–º–Ω–æ–≥–æ –¥—Ä–µ–π—Ñ–∞ –∫ —Ü–µ–Ω—Ç—Ä—É –∏ –ª–µ–≥–∫–∞—è —Ä–µ–∞–∫—Ü–∏—è –Ω–∞ –∏–≥—Ä–æ–∫–∞
    const targetX = lerp(CX, player.x, 0.15);
    const targetY = lerp(H*0.3, player.y, 0.15);
    const desiredAngle = angleBetween(boss.x, boss.y, targetX, targetY);
    const accel = 30 + boss.phase*10;
    boss.vx += Math.cos(desiredAngle) * accel * dt;
    boss.vy += Math.sin(desiredAngle) * accel * dt;
    const maxSpeed = 90 + boss.phase*20;
    const sp = len(boss.vx, boss.vy);
    if (sp > maxSpeed) {
      boss.vx *= maxSpeed / sp;
      boss.vy *= maxSpeed / sp;
    }
    boss.x += boss.vx * dt;
    boss.y += boss.vy * dt;
    boss.vx *= 0.95; boss.vy *= 0.95;

    // –°—É–±—Å–æ—Å—Ç–æ—è–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ä—ã–≤–æ–∫)
    if (boss.substate === 'transition') {
      boss.subTimer -= dt;
      if (boss.subTimer <= 0) boss.substate = 'idle';
      // –í–æ –≤—Ä–µ–º—è –ø–µ—Ä–µ—Ö–æ–¥–∞ ‚Äî –∫–æ–ª—å—Ü–µ–≤–æ–π –≤–∑—Ä—ã–≤
      if (boss.timers.ring <= 0) {
        ringAttack(24 + boss.phase * 6, 180 + boss.phase*30);
        boss.timers.ring = 99; // –æ–¥–∏–Ω —Ä–∞–∑ –≤ –ø–µ—Ä–µ—Ö–æ–¥–µ
      }
      return;
    }

    // –ê—Ç–∞–∫–∏ –ø–æ —Ñ–∞–∑–∞–º
    if (boss.phase === 1) phase1(dt);
    else if (boss.phase === 2) phase2(dt);
    else phase3(dt);
  }

  function ringAttack(count, speed, offset=0, color='#ff6b9e', size=5) {
    for (let i = 0; i < count; i++) {
      const a = offset + i * (TAU / count);
      spawnBossBullet(boss.x, boss.y, a, speed, size, 'normal', color);
    }
    addShake(3);
    audio.beep('square', 220, 0.08, 0.04);
  }

  function aimedBurst(n = 5, spread = 0.25, speed = 240) {
    const base = angleBetween(boss.x, boss.y, player.x, player.y);
    for (let i = 0; i < n; i++) {
      const a = base + lerp(-spread, spread, i/(n-1));
      spawnBossBullet(boss.x, boss.y, a, speed, 5);
    }
    audio.beep('sine', 360, 0.05, 0.03);
  }

  function spiralAttack(stepDir = 1, rate = 0.05, speed = 260, size=5) {
    if (boss.timers.spiral <= 0) {
      if (!spiralAttack.angle) spiralAttack.angle = 0;
      spiralAttack.angle += stepDir * 0.42;
      spawnBossBullet(boss.x, boss.y, spiralAttack.angle, speed, size, 'normal', '#ff8bb6');
      spawnBossBullet(boss.x, boss.y, spiralAttack.angle + Math.PI, speed, size, 'normal', '#ff8bb6');
      boss.timers.spiral = rate;
    }
  }

  function dashAttack(dt) {
    if (boss.timers.dash <= 0 && boss.substate !== 'dashing') {
      boss.substate = 'dashing';
      boss.subTimer = 0.9;
      const a = angleBetween(boss.x, boss.y, player.x, player.y);
      boss.vx = Math.cos(a) * (280 + boss.phase*40);
      boss.vy = Math.sin(a) * (280 + boss.phase*40);
      // –¢–µ–ª–µ–≥—Ä–∞—Ñ ‚Äî –Ω–µ–±–æ–ª—å—à–æ–π –≤–µ–µ—Ä –ø—Ä–∏—Ü–µ–ª—å–Ω—ã—Ö —Å–Ω–∞—Ä—è–¥–æ–≤ –ø–µ—Ä–µ–¥ —Ä—ã–≤–∫–æ–º
      aimedBurst(3, 0.15, 260);
      boss.timers.dash = rand(3.8, 5.5) - boss.phase*0.35;
    }
    if (boss.substate === 'dashing') {
      boss.subTimer -= dt;
      if (boss.subTimer <= 0) {
        boss.substate = 'idle';
        // –ü–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ ‚Äî –∫–æ–ª—å—Ü–æ
        ringAttack(10 + boss.phase*3, 210 + boss.phase*25);
      }
    }
  }

  function missileAttack(count = 3, turn = 1.5, speed = 200) {
    for (let i = 0; i < count; i++) {
      const a = rand(0, TAU);
      const b = { x: boss.x, y: boss.y };
      const bullet = { x: b.x, y: b.y, vx: Math.cos(a)*speed, vy: Math.sin(a)*speed, r: 5.5, life: 8, type: 'missile', color: '#ff9abf', angle: a, turn };
      bossBullets.push(bullet);
    }
    audio.beep('sawtooth', 480, 0.06, 0.03);
  }

  function phase1(dt) {
    // –ú–∞–ª–µ–Ω—å–∫–∏–µ –∞–Ω—Ç–∏–≤–∏—Ä—É—Å—ã (—Ö–∞–æ—Ç–∏—á–Ω—ã–µ) ‚Äî —É–º–µ—Ä–µ–Ω–Ω–æ
    if (boss.timers.drone <= 0) {
      for (let i = 0; i < 2; i++) spawnDrone();
      boss.timers.drone = rand(2.2, 3.2);
    }
    // –ü—Ä–∏—Ü–µ–ª—å–Ω—ã–µ –æ—á–µ—Ä–µ–¥–∏
    if (boss.timers.aimed <= 0) {
      aimedBurst(5, 0.3, 240);
      boss.timers.aimed = rand(1.1, 1.6);
    }
    // –ö–æ–ª—å—Ü–æ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏
    if (boss.timers.ring <= 0) {
      ringAttack(16, 190);
      boss.timers.ring = rand(4.8, 6.0);
    }
  }

  function phase2(dt) {
    // –î—Ä–æ–Ω–æ–≤ –±–æ–ª—å—à–µ
    if (boss.timers.drone <= 0) {
      for (let i = 0; i < 3; i++) spawnDrone();
      boss.timers.drone = rand(1.6, 2.2);
    }
    // –°–ø–∏—Ä–∞–ª—å–Ω—ã–µ —Å–Ω–∞—Ä—è–¥—ã
    spiralAttack(1, 0.045, 280, 5);
    // –†—ã–≤–∫–∏
    dashAttack(dt);
    // –ö–æ–ª—å—Ü–æ —Ä–µ–∂–µ, –Ω–æ –ø–ª–æ—Ç–Ω–µ–µ
    if (boss.timers.ring <= 0) {
      ringAttack(24, 210);
      boss.timers.ring = rand(5.0, 6.5);
    }
  }

  function phase3(dt) {
    // –û—á–µ–Ω—å –º–Ω–æ–≥–æ —Ö–∞–æ—Å–∞
    if (boss.timers.drone <= 0) {
      for (let i = 0; i < 4; i++) spawnDrone();
      boss.timers.drone = rand(1.2, 1.8);
    }
    // –î–≤–æ–π–Ω–∞—è —Å–ø–∏—Ä–∞–ª—å, –±—ã—Å—Ç—Ä–µ–µ
    spiralAttack(1, 0.032, 320, 5);
    // –°—Ç–µ–Ω—ã –∏–∑ –¥—É–≥
    if (boss.timers.sweep <= 0) {
      const base = rand(0, TAU);
      for (let k = 0; k < 3; k++) {
        const a = base + k * 0.28;
        for (let i = 0; i < 18; i++) {
          const aa = a + i * 0.05;
          spawnBossBullet(boss.x, boss.y, aa, 220, 4.8, 'normal', '#ffa3c3');
        }
      }
      boss.timers.sweep = rand(4.2, 5.6);
    }
    // –ù–µ–º–Ω–æ–≥–æ —Å–∞–º–æ–Ω–∞–≤–æ–¥—è—â–∏—Ö—Å—è
    if (boss.timers.missile <= 0) {
      missileAttack(3 + randInt(0,1), 1.7, 220);
      boss.timers.missile = rand(3.0, 4.2);
    }
    // –†–µ–¥–∫–∏–µ —Ä—ã–≤–∫–∏
    dashAttack(dt);
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∏—Ä–∞
  function update(dt) {
    // –ò–≥—Ä–æ–∫
    const ax = (keys.has('KeyD') || keys.has('ArrowRight') ? 1 : 0) - (keys.has('KeyA') || keys.has('ArrowLeft') ? 1 : 0);
    const ay = (keys.has('KeyS') || keys.has('ArrowDown') ? 1 : 0) - (keys.has('KeyW') || keys.has('ArrowUp') ? 1 : 0);
    const accel = 1200;
    player.vx += ax * accel * dt;
    player.vy += ay * accel * dt;
    const maxSpd = 320;
    const sp = len(player.vx, player.vy);
    if (sp > maxSpd) { player.vx *= maxSpd/sp; player.vy *= maxSpd/sp; }

    player.x += player.vx * dt;
    player.y += player.vy * dt;
    player.vx *= player.friction;
    player.vy *= player.friction;

    // –ì—Ä–∞–Ω–∏—Ü—ã
    const pr = player.r + 2;
    player.x = clamp(player.x, pr, W - pr);
    player.y = clamp(player.y, pr, H - pr);

    // –£–≥–æ–ª –∫ –º—ã—à–∏
    player.angle = angleBetween(player.x, player.y, mouse.x, mouse.y);

    // –°—Ç—Ä–µ–ª—å–±–∞
    player.shootCD -= dt;
    if (mouse.down && player.shootCD <= 0) {
      spawnPlayerBullet();
      player.shootCD = player.shootRate;
    }

    if (player.invul > 0) player.invul -= dt;

    // –ë–æ—Å—Å
    bossBehavior(dt);

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–æ–≤ –∏–≥—Ä–æ–∫–∞
    for (let i = playerBullets.length - 1; i >= 0; i--) {
      const b = playerBullets[i];
      b.x += b.vx * dt; b.y += b.vy * dt;
      b.life -= dt;
      // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –±–æ—Å—Å–æ–º
      const dx = b.x - boss.x, dy = b.y - boss.y;
      if (dx*dx + dy*dy < (b.r + boss.r) * (b.r + boss.r)) {
        // —É—Ä–æ–Ω –±–æ—Å—Å—É –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ñ–∞–∑—ã
        const dmg = 4.8 + boss.phase*0.6;
        boss.hp -= dmg;
        spawnParticles(b.x, b.y, '#43f0ff', 10, 180, 0.4);
        addShake(2);
        audio.beep('triangle', 540, 0.05, 0.03);
        b.life = 0;
        updateHUD();
      }
      if (b.life <= 0 || b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) {
        playerBullets.splice(i, 1);
      }
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–æ–≤ –±–æ—Å—Å–∞
    for (let i = bossBullets.length - 1; i >= 0; i--) {
      const b = bossBullets[i];
      // –°–∞–º–æ–Ω–∞–≤–æ–¥—è—â–∏–µ—Å—è –Ω–µ–º–Ω–æ–≥–æ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É—é—Ç —É–≥–æ–ª
      if (b.type === 'missile') {
        const targetAngle = angleBetween(b.x, b.y, player.x, player.y);
        const diff = normalizeAngle(targetAngle - b.angle);
        const maxTurn = (b.turn || 1.5) * dt; // —Ä–∞–¥/—Å
        const da = clamp(diff, -maxTurn, maxTurn);
        b.angle += da;
        const spd = len(b.vx, b.vy);
        b.vx = Math.cos(b.angle) * spd;
        b.vy = Math.sin(b.angle) * spd;
      }
      b.x += b.vx * dt; b.y += b.vy * dt;
      b.life -= dt;

      // –ü–æ–ø–∞–¥–∞–Ω–∏–µ –ø–æ –∏–≥—Ä–æ–∫—É
      if (player.alive && player.invul <= 0) {
        const dx = b.x - player.x, dy = b.y - player.y;
        if (dx*dx + dy*dy < (b.r + player.r)*(b.r + player.r)) {
          hitPlayer(1, b.x, b.y);
          b.life = 0;
        }
      }
      if (b.life <= 0 || b.x < -40 || b.x > W+40 || b.y < -40 || b.y > H+40) {
        bossBullets.splice(i, 1);
      }
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥—Ä–æ–Ω–æ–≤ (—Ö–∞–æ—Ç–∏—á–Ω—ã—Ö –º–∞–ª–µ–Ω—å–∫–∏—Ö –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–æ–≤)
    for (let i = drones.length - 1; i >= 0; i--) {
      const d = drones[i];
      // –°–ª—É—á–∞–π–Ω–∞—è —Å–º–µ–Ω–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è ‚Äî —Ö–∞–æ—Å
      const jitter = d.jitter * 2.6;
      d.vx += rand(-jitter, jitter);
      d.vy += rand(-jitter, jitter);
      // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
      const spd = len(d.vx, d.vy);
      const max = 130 + boss.phase*25;
      if (spd > max) { d.vx *= max/spd; d.vy *= max/spd; }

      d.x += d.vx * dt; d.y += d.vy * dt;

      // –û—Ç—Å–∫–æ–∫ –æ—Ç –∫—Ä–∞—ë–≤
      if (d.x < 20 || d.x > W-20) { d.vx *= -1; d.x = clamp(d.x, 20, W-20); }
      if (d.y < 20 || d.y > H-20) { d.vy *= -1; d.y = clamp(d.y, 20, H-20); }

      d.life -= dt;

      // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –∏–≥—Ä–æ–∫–æ–º
      if (player.alive && player.invul <= 0) {
        const dx = d.x - player.x, dy = d.y - player.y;
        if (dx*dx + dy*dy < (d.r + player.r)*(d.r + player.r)) {
          hitPlayer(1, d.x, d.y);
          d.life = 0;
        }
      }

      if (d.life <= 0) {
        spawnParticles(d.x, d.y, '#ffd166', 8, 140, 0.5);
        drones.splice(i, 1);
      }
    }

    // –ß–∞—Å—Ç–∏—Ü—ã
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.life -= dt;
      p.vx *= 0.98; p.vy *= 0.98;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ HUD
    updateHUD();

    // –≠—Ñ—Ñ–µ–∫—Ç —Ç—Ä—è—Å–∫–∏
    shake = Math.max(0, shake - dt * 18);
  }

  function normalizeAngle(a) {
    while (a > Math.PI) a -= TAU;
    while (a < -Math.PI) a += TAU;
    return a;
  }

  function hitPlayer(dmg, sx, sy) {
    if (!player.alive || player.invul > 0) return;
    player.lives -= dmg;
    player.invul = 1.1;
    spawnParticles(player.x, player.y, '#39e8ff', 24, 220, 0.7);
    addShake(8);
    audio.beep('sawtooth', 160, 0.12, 0.06);
    if (player.lives <= 0) {
      player.alive = false;
      gameLose();
    }
  }

  // –†–µ–Ω–¥–µ—Ä
  function render() {
    // –§–æ–Ω–æ–≤–∞—è —Å–µ—Ç–∫–∞/–≤–∏–Ω–∏–µ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
    ctx.clearRect(0, 0, W, H);
    drawBackground();

    // –ö–∞–º–µ—Ä–∞ —Å–æ —Å–º–µ—â–µ–Ω–∏–µ–º –ø—Ä–∏ —Ç—Ä—è—Å–∫–µ
    ctx.save();
    if (shake > 0) ctx.translate(rand(-shake, shake), rand(-shake, shake));

    // –ë–æ—Å—Å
    drawBoss();

    // –î—Ä–æ–Ω—ã
    for (const d of drones) drawDrone(d);

    // –°–Ω–∞—Ä—è–¥—ã –±–æ—Å—Å–∞
    for (const b of bossBullets) drawBossBullet(b);

    // –°–Ω–∞—Ä—è–¥—ã –∏–≥—Ä–æ–∫–∞
    for (const b of playerBullets) drawPlayerBullet(b);

    // –ò–≥—Ä–æ–∫
    drawPlayer();

    // –ß–∞—Å—Ç–∏—Ü—ã
    for (const p of particles) drawParticle(p);

    ctx.restore();

    // –ö—É—Ä—Å–æ—Ä-–ø—Ä–∏—Ü–µ–ª
    drawCrosshair();
  }

  function drawBackground() {
    // –ú—è–≥–∫–∞—è —Å–µ—Ç–∫–∞
    const step = 40;
    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.strokeStyle = '#0f2a3a';
    ctx.lineWidth = 1;
    for (let x = (performance.now()*0.02 % step); x < W; x += step) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    for (let y = (performance.now()*0.02 % step); y < H; y += step) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawPlayer() {
    const blink = player.invul > 0 ? (Math.sin(performance.now()*0.02) > 0 ? 0.45 : 1) : 1;
    ctx.save();
    if (glowEnabled) { ctx.shadowColor = '#39e8ff'; ctx.shadowBlur = 12; }
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    ctx.globalAlpha = 0.9 * blink;

    // –¢–µ–ª–æ –≤–∏—Ä—É—Å–∞ ‚Äî –∫–∞–ø–ª–µ–≤–∏–¥–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
    ctx.fillStyle = '#39e8ff';
    ctx.beginPath();
    ctx.moveTo(16, 0);
    ctx.lineTo(-12, 10);
    ctx.lineTo(-6, 0);
    ctx.lineTo(-12, -10);
    ctx.closePath();
    ctx.fill();

    // –ö–æ–Ω—Ç—É—Ä
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(57,232,255,0.7)';
    ctx.stroke();

    ctx.restore();
  }

  function drawBoss() {
    ctx.save();
    if (glowEnabled) { ctx.shadowColor = '#ff2a6f'; ctx.shadowBlur = 20; }
    ctx.globalAlpha = 0.95;

    // –¢–µ–ª–æ
    const r = boss.r;
    const grd = ctx.createRadialGradient(boss.x, boss.y, r*0.2, boss.x, boss.y, r);
    grd.addColorStop(0, '#ff2a6f');
    grd.addColorStop(1, '#7f0f2f');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(boss.x, boss.y, r, 0, TAU);
    ctx.fill();

    // –û–±–æ–¥
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,42,111,0.8)';
    ctx.stroke();

    // –ì–ª–∞–∑/—Å–∫–∞–Ω–µ—Ä –≤ —Å—Ç–æ—Ä–æ–Ω—É –∏–≥—Ä–æ–∫–∞
    const a = angleBetween(boss.x, boss.y, player.x, player.y);
    const eyeR = r*0.45;
    ctx.translate(boss.x, boss.y);
    ctx.rotate(a);
    ctx.fillStyle = '#ff8bb6';
    ctx.beginPath();
    ctx.ellipse(r*0.2, 0, eyeR*0.55, eyeR*0.35, 0, 0, TAU);
    ctx.fill();

    ctx.restore();
  }

  function drawDrone(d) {
    ctx.save();
    if (glowEnabled) { ctx.shadowColor = '#ffd166'; ctx.shadowBlur = 10; }
    ctx.translate(d.x, d.y);
    const a = Math.atan2(d.vy, d.vx);
    ctx.rotate(a);
    ctx.fillStyle = '#ffd166';
    ctx.beginPath();
    ctx.moveTo(10, 0);
    ctx.lineTo(-8, 6);
    ctx.lineTo(-6, 0);
    ctx.lineTo(-8, -6);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'rgba(255, 209, 102, 0.8)';
    ctx.stroke();
    ctx.restore();
  }

  function drawBossBullet(b) {
    ctx.save();
    if (glowEnabled) { ctx.shadowColor = b.color || '#ff6b9e'; ctx.shadowBlur = 10; }
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = b.color || '#ff6b9e';
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, TAU);
    ctx.fill();
    ctx.restore();
  }

  function drawPlayerBullet(b) {
    ctx.save();
    if (glowEnabled) { ctx.shadowColor = '#39e8ff'; ctx.shadowBlur = 8; }
    ctx.fillStyle = '#39e8ff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, TAU);
    ctx.fill();
    ctx.restore();
  }

  function drawParticle(p) {
    ctx.save();
    if (glowEnabled) { ctx.shadowColor = p.color; ctx.shadowBlur = 10; }
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, TAU);
    ctx.fill();
    ctx.restore();
  }

  function drawCrosshair() {
    ctx.save();
    ctx.translate(mouse.x, mouse.y);
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#7fe8ff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, TAU);
    ctx.moveTo(-12, 0); ctx.lineTo(-4, 0);
    ctx.moveTo(12, 0); ctx.lineTo(4, 0);
    ctx.moveTo(0, -12); ctx.lineTo(0, -4);
    ctx.moveTo(0, 12); ctx.lineTo(0, 4);
    ctx.stroke();
    ctx.restore();
  }

  // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
  let last = 0;
  function tick(t) {
    const time = t || performance.now();
    let dt = (time - last) / 1000;
    if (!last) dt = 0;
    last = time;

    // –û–≥—Ä–∞–Ω–∏—á–∏–º dt, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Å–∫–∞—á–∫–æ–≤ –ø–æ—Å–ª–µ –≤–∫–ª–∞–¥–∫–∏ –≤ —Ñ–æ–Ω–µ
    dt = Math.min(dt, 1/30);

    if (gameState === State.Playing) {
      update(dt);
    }
    render();
    mouse.justPressed = false;
    requestAnimationFrame(tick);
  }

  // –ü–∞—É–∑–∞/–†–µ—Å—Ç–∞—Ä—Ç/–ö–æ–Ω–µ—Ü
  function togglePause() {
    if (gameState === State.Playing) {
      gameState = State.Paused;
      pauseOverlay.style.display = '';
    } else if (gameState === State.Paused) {
      gameState = State.Playing;
      pauseOverlay.style.display = 'none';
    }
  }

  function startGame() {
    menu.style.display = 'none';
    endOverlay.style.display = 'none';
    pauseOverlay.style.display = 'none';
    resetGame();
    gameState = State.Playing;
    audio.init();
  }

  function gameWin() {
    gameState = State.Win;
    endOverlay.style.display = '';
    endPanel.innerHTML = `
      <h3>–ü–æ–±–µ–¥–∞!</h3>
      <p>–¢—ã –∑–∞—Ä–∞–∑–∏–ª –ê–Ω—Ç–∏–≤–∏—Ä—É—Å –∏ –ø–µ—Ä–µ–∂–∏–ª –≤—Å–µ 3 —Ñ–∞–∑—ã.</p>
      <a class="btn" id="restartBtn">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</a>
    `;
    document.getElementById('restartBtn').onclick = startGame;
    audio.beep('triangle', 660, 0.12, 0.05);
    audio.beep('triangle', 880, 0.18, 0.05);
  }

  function gameLose() {
    gameState = State.Lose;
    endOverlay.style.display = '';
    endPanel.innerHTML = `
      <h3>–ü—Ä–æ–∏–≥—Ä—ã—à</h3>
      <p>–ê–Ω—Ç–∏–≤–∏—Ä—É—Å –æ–∫–∞–∑–∞–ª—Å—è –∫—Ä–µ–ø–∫–∏–º –æ—Ä–µ—à–∫–æ–º. –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â—ë?</p>
      <a class="btn" id="restartBtn">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å</a>
    `;
    document.getElementById('restartBtn').onclick = startGame;
    audio.beep('sawtooth', 200, 0.2, 0.07);
    audio.beep('sawtooth', 140, 0.3, 0.07);
  }

  startBtn.addEventListener('click', startGame);

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
  resize();
  tick();

})();
</script>
</body>
</html>
